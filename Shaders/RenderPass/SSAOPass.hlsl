// clang-format off
#include "RootSignature/BindlessRS.hlsli"
#include "ShaderInterlop/ConstantBuffers.hlsli"
#include "ShaderInterlop/RenderResources.hlsli"
#include "Utils.hlsli"

ConstantBuffer<interlop::SSAORenderResources> renderResources : register(b0);

// clang-format on
[RootSignature(BindlessRootSignature)][numthreads(12, 8, 1)] void CsMain(uint3 dispatchThreadID
                                                                         : SV_DispatchThreadID, uint groupIndex
                                                                         : SV_GroupIndex) {
    ConstantBuffer<interlop::SSAOBuffer> ssaoBuffer = ResourceDescriptorHeap[renderResources.ssaoBufferIndex];
    ConstantBuffer<interlop::SceneBuffer> sceneBuffer = ResourceDescriptorHeap[renderResources.sceneBufferIndex];

    const float2 uv = (dispatchThreadID.xy + 0.5f) * 1.0f / ssaoBuffer.screenDimensions;

    RWTexture2D<float> outputTexture = ResourceDescriptorHeap[renderResources.outputTextureIndex];
    Texture2D<float4> normalTexture = ResourceDescriptorHeap[renderResources.normalTextureIndex];
    Texture2D<float2> randomRotationTexture = ResourceDescriptorHeap[renderResources.randomRotationTextureIndex];
    Texture2D<float> depthTexture = ResourceDescriptorHeap[renderResources.depthTextureIndex];

    const float3 randomVector =
        float3(randomRotationTexture
                   .Sample(pointWrapSampler, uv * ssaoBuffer.noiseScaleDimensions)
                   .xy,
               0.0f);

    const float3 viewSpaceNormal = normalize(normalTexture.Sample(pointClampSampler, uv).xyz);

    const float3 viewSpacePosition = viewSpaceCoordsFromDepthBuffer(depthTexture.Sample(pointClampSampler, uv), uv,
                                                                    sceneBuffer.inverseProjectionMatrix);

    // The tangent is generated by taking the random vector and normal into account and using the Gramm Schmidt Process.

    const float3 tangent = normalize(randomVector - viewSpaceNormal * dot(randomVector, viewSpaceNormal));
    const float3 biTangent = cross(viewSpaceNormal, tangent);

    const float3x3 tbnMatrix = float3x3(tangent, biTangent, viewSpaceNormal);

    float occlusion = 0.0f;

    [unroll(32)] for (uint i = 0; i < interlop::SAMPLE_VECTOR_COUNT; ++i)
    {
        float3 samplePosition = viewSpacePosition + mul(ssaoBuffer.sampleVectors[i].xyz, tbnMatrix) * ssaoBuffer.radius;

        // Transforming sample position to clip space.
        float4 clipSpacePosition = float4(samplePosition, 1.0f);

        clipSpacePosition = mul(clipSpacePosition, sceneBuffer.projectionMatrix);
        clipSpacePosition.xy /= clipSpacePosition.w;

        // Conversion from -1..1 to 0..1.
        clipSpacePosition.xy = clipSpacePosition.xy * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);

        // Get the view space sample depth.
        float sampleDepth = depthTexture.Sample(pointClampSampler, clipSpacePosition.xy);
        sampleDepth = viewSpaceCoordsFromDepthBuffer(sampleDepth, uv, sceneBuffer.inverseProjectionMatrix).z;

        const float rangeCheck = smoothstep(0.0f, 1.0f, ssaoBuffer.radius / abs(sampleDepth - viewSpacePosition.z));

        occlusion += rangeCheck * step(sampleDepth, samplePosition.z + ssaoBuffer.bias);
    }

    outputTexture[dispatchThreadID.xy] =
        pow(abs(1.0f - (ssaoBuffer.occlusionMultiplier * occlusion / (float)interlop::SAMPLE_VECTOR_COUNT)),
            ssaoBuffer.power);
}