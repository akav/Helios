// clang-format off
#include "RootSignature/BindlessRS.hlsli"
#include "ShaderInterlop/ConstantBuffers.hlsli"
#include "ShaderInterlop/RenderResources.hlsli"
#include "Utils.hlsli"

ConstantBuffer<interlop::SSAORenderResources> renderResources : register(b0);

groupshared interlop::SSAOBuffer ssaoBuffer;

// clang-format on
[RootSignature(BindlessRootSignature)]
[numthreads(8, 12, 1)]
void CsMain(uint3 dispatchThreadID : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex)
{
    ConstantBuffer<interlop::SSAOBuffer> ssaoBuffer = ResourceDescriptorHeap[renderResources.ssaoBufferIndex];
    ConstantBuffer<interlop::SceneBuffer> sceneBuffer = ResourceDescriptorHeap[renderResources.sceneBufferIndex];
    
    RWTexture2D<float> outputTexture = ResourceDescriptorHeap[renderResources.outputTextureIndex];
    float width, height;
    outputTexture.GetDimensions(width, height);

    const float2 uv = (dispatchThreadID.xy + 0.5f) * 1.0f / float2(width, height);

    Texture2D<float4> normalTexture = ResourceDescriptorHeap[renderResources.normalTextureIndex];

    Texture2D<float2> randomRotationTexture = ResourceDescriptorHeap[renderResources.randomRotationTextureIndex];

    Texture2D<float> depthTexture = ResourceDescriptorHeap[renderResources.depthTextureIndex];

    const float3 randomVector = float3(
        randomRotationTexture
            .Sample(pointWrapSampler,
                    uv * float2((float)ssaoBuffer.screenWidth / (float)ssaoBuffer.noiseTextureWidth,
                                                (float)ssaoBuffer.screenHeight / (float)ssaoBuffer.noiseTextureHeight))
            .xy,
        0.0f);

    const float currentPixelDepth = depthTexture.Sample(pointClampSampler, uv);
    const float3 viewSpaceNormal = normalize(normalTexture.Sample(linearWrapSampler, uv).xyz);

    const float3 viewSpacePosition =
        viewSpaceCoordsFromDepthBuffer(currentPixelDepth, uv, sceneBuffer.inverseProjectionMatrix);

    // The tangent is generated by taking the random vector and normal into account and using the Gramm Schmidt Process.

    const float3 tangent = normalize(randomVector - viewSpaceNormal * dot(randomVector, viewSpaceNormal));
    const float3 biTangent = cross(viewSpaceNormal, tangent);

    const float3x3 tbnMatrix = float3x3(tangent, biTangent, viewSpaceNormal);

    float occlusion = 0.0f;

    [unroll(32)] for (uint i = 0; i < ssaoBuffer.sampleVectorCount; ++i)
    {
        const float3 viewSpaceSampleVector = mul(ssaoBuffer.sampleVectors[i].xyz, tbnMatrix);
        float4 samplePosition = float4(viewSpacePosition + viewSpaceSampleVector * ssaoBuffer.radius,
                                       1.0f); // Basically placing the normal oriented hemisphere sampled position over
                                              // the corresponding view space position.
        const float samplePositionDepth = samplePosition.z;

        // Transforming sample position to clip space.
        samplePosition = mul(samplePosition, sceneBuffer.projectionMatrix);
        samplePosition.xy /= samplePosition.w;

        // Conversion from -1..1 to 0..1.
        samplePosition.xy = samplePosition.xy * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);

        // Get the view space sample depth.
        float sampleDepth = depthTexture.Sample(pointClampSampler, samplePosition.xy);
        sampleDepth = viewSpaceCoordsFromDepthBuffer(sampleDepth, uv, sceneBuffer.inverseProjectionMatrix).z;

        const float rangeCheck = smoothstep(0.0f, 1.0f, ssaoBuffer.radius / abs(sampleDepth - viewSpacePosition.z));

        occlusion += rangeCheck * ((samplePositionDepth + ssaoBuffer.bias) <= sampleDepth ? 0.0f : 1.0f);
    }

    outputTexture[dispatchThreadID.xy] = pow(abs(1.0f - (ssaoBuffer.occlusionMultiplier * occlusion / (float)ssaoBuffer.sampleVectorCount)),
               ssaoBuffer.power);
}