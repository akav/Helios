// clang-format off
#include "RootSignature/BindlessRS.hlsli"
#include "ShaderInterlop/ConstantBuffers.hlsli"
#include "ShaderInterlop/RenderResources.hlsli"
#include "Utils.hlsli"

struct VSOutput
{
    float4 position : SV_Position;
    float2 textureCoord : Texture_Coord;

    float4x4 inverseProjectionMatrix: INVERSE_PROJECTION_MATRIX;
    float4x4 projectionMatrix: PROJECTION_MATRIX;
};

ConstantBuffer<interlop::SSAORenderResources> renderResources : register(b0);

[RootSignature(BindlessRootSignature)]
VSOutput VsMain(uint vertexID : SV_VertexID)
{
    float3 VERTEX_POSITIONS[3] = {float3(-1.0f, 1.0f, 0.0f), float3(3.0f, 1.0f, 0.0f),
                                               float3(-1.0f, -3.0f, 0.0f)};

    VSOutput output;
    output.position = float4(VERTEX_POSITIONS[vertexID], 1.0f);
    output.textureCoord = output.position.xy * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);

    ConstantBuffer<interlop::SceneBuffer> sceneBuffer = ResourceDescriptorHeap[renderResources.sceneBufferIndex];
    
    output.inverseProjectionMatrix = sceneBuffer.inverseProjectionMatrix;
    output.projectionMatrix = sceneBuffer.projectionMatrix;

    return output;
}

// clang-format on
float PsMain(VSOutput input)
    : SV_Target
{
    ConstantBuffer<interlop::SSAOBuffer> ssaoBuffer = ResourceDescriptorHeap[renderResources.ssaoBufferIndex];

    Texture2D<float4> normalTexture = ResourceDescriptorHeap[renderResources.normalTextureIndex];
    Texture2D<float2> randomRotationTexture = ResourceDescriptorHeap[renderResources.randomRotationTextureIndex];

    Texture2D<float> depthTexture = ResourceDescriptorHeap[renderResources.depthTextureIndex];

    const float3 randomVector = float3(
        randomRotationTexture
            .Sample(pointWrapSampler,
                    input.textureCoord * float2((float)ssaoBuffer.screenWidth / (float)ssaoBuffer.noiseTextureWidth,
                                                (float)ssaoBuffer.screenHeight / (float)ssaoBuffer.noiseTextureHeight))
            .xy,
        0.0f);

    const float currentPixelDepth = depthTexture.Sample(pointClampSampler, input.textureCoord);
    const float3 viewSpaceNormal = normalize(normalTexture.Sample(linearWrapSampler, input.textureCoord).xyz);

    const float3 viewSpacePosition =
        viewSpaceCoordsFromDepthBuffer(currentPixelDepth, input.textureCoord, input.inverseProjectionMatrix);

    // The tangent is generated by taking the random vector and normal into account and using the Gramm Schmidt Process.

    const float3 tangent = normalize(randomVector - viewSpaceNormal * dot(randomVector, viewSpaceNormal));
    const float3 biTangent = cross(viewSpaceNormal, tangent);

    const float3x3 tbnMatrix = float3x3(tangent, biTangent, viewSpaceNormal);

    float occlusion = 0.0f;

    [unroll(32)] for (uint i = 0; i < ssaoBuffer.sampleVectorCount; ++i)
    {
        const float3 viewSpaceSampleVector = mul(ssaoBuffer.sampleVectors[i].xyz, tbnMatrix);
        float4 samplePosition = float4(viewSpacePosition + viewSpaceSampleVector * ssaoBuffer.radius,
                                       1.0f); // Basically placing the normal oriented hemisphere sampled position over
                                              // the corresponding view space position.
        const float samplePositionDepth = samplePosition.z;

        // Transforming sample position to clip space.
        samplePosition = mul(samplePosition, input.projectionMatrix);
        samplePosition.xy /= samplePosition.w;

        // Conversion from -1..1 to 0..1.
        samplePosition.xy = samplePosition.xy * float2(0.5f, -0.5f) + float2(0.5f, 0.5f);

        // Get the view space sample depth.
        float sampleDepth = depthTexture.Sample(pointClampSampler, samplePosition.xy);
        sampleDepth = viewSpaceCoordsFromDepthBuffer(sampleDepth, input.textureCoord, input.inverseProjectionMatrix).z;

        const float rangeCheck = smoothstep(0.0f, 1.0f, ssaoBuffer.radius / abs(sampleDepth - viewSpacePosition.z));

        occlusion += rangeCheck * ((samplePositionDepth + ssaoBuffer.bias) <= sampleDepth ? 0.0f : 1.0f);
    }

    return pow(abs(1.0f - (ssaoBuffer.occlusionMultiplier * occlusion / (float)ssaoBuffer.sampleVectorCount)),
               ssaoBuffer.power);
}